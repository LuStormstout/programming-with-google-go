package main

import "fmt"

func main() {
	pointer()
	scope()
	scope2()
}

// ------------------------------ 指针 ------------------------------
// 指针是存储另一个变量的内存地址的变量
// 指针指向值的内存地址，而不是值本身
// 指针类型前缀为 *，指针指向的值称为目标
// 指针的零值是 nil
// 指针的类型为 *T，T 为指针指向的类型
// Go 不支持指针运算
// Go 语言中的指针操作只需要记住两个符号：&（取地址）和 *（根据地址取值）
// Go 语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string 等
// 值类型包括：基本类型、数组、结构体
// 引用类型包括：指针、slice 切片、map、管道 channel、interface 等
// 值类型的变量的值存储在栈中
// 引用类型的变量的值存储在堆中，或者存储在栈中，但是值本身是指针
// 值类型的变量的值在内存中的地址不会改变
// 引用类型的变量的值在内存中的地址会改变
// 值类型的变量赋值给另一个变量，会拷贝一份新的值，两个变量的值是完全独立的
// 引用类型的变量赋值给另一个变量，不会拷贝新的值，两个变量的值是同一个值，任何一个变量的值发生改变，另一个变量的值也会改变
// 值类型的变量作为参数传递给函数时，传递的是一份新的值，函数中对该值的修改，不会影响到原来的值
// 引用类型的变量作为参数传递给函数时，传递的是该值的指针，函数中对该值的修改，会影响到原来的值
// map、slice、channel 这三种引用类型的变量，创建之后就可以直接使用，不用像 C 语言那样先声明后初始化，再使用

// pointer 指针
func pointer() {
	// 指针
	// & 取地址，是内存中的虚拟地址
	// * 取值，是内存中的实际值

	var x = 1 // 声明一个int类型的变量，值为1
	var y int // 声明一个int类型的变量，默认值为0

	var ip *int // 声明一个int类型的指针

	ip = &x // 指针指向x的地址
	y = *ip // y是指针ip的值，即x的值 1

	ptr := new(int) // new函数创建一个指针, 指向一个int类型的内存地址, 值为0
	*ptr = 3        // 指针ptr的值为3,*ptr 就是指针ptr的值, 即3

	fmt.Println(x, y, ip) // 1 1 0xc0000140b0
}

// ------------------------------ 变量作用域 ------------------------------
// 变量的作用域，就是变量的有效范围
// 即变量在什么范围内可以使用，超出范围就不能使用
// 这个范围就是变量的作用域，也叫变量的生命周期，变量的作用域分为全局变量和局部变量
// 全局变量：在函数体外声明的变量，作用域为整个包内都可以使用
// 局部变量：在函数体内声明的变量，作用域为函数体内部
// 函数的参数也是局部变量，作用域为函数体内部

var x = 4 // 全局变量

// scope 作用域
func scope() {
	// 全局变量 x 虽然不在 scope 函数中定义，但是可以在 scope 函数中使用
	fmt.Printf("全局变量 x = %d \n", x)

	// 报错，局部变量 y 不能在 scope2 函数外使用
	//fmt.Println(y)
}

// scope2 作用域
func scope2() {
	var x = 3 // 局部变量
	var y = 4 // 局部变量

	// 全局变量 x 会被局部变量 x 覆盖，所以这里 x = 3
	fmt.Printf("在 scope2 中 x 被重新定义覆盖了全局变量中的 x 所以这里 x = %d \n", x)

	// 局部变量 y 在 scope2 中定义所以只能在 scope2 中使用
	fmt.Printf("局部变量 y 在 scope2 中定义所以只能在 scope2 中使用 y = %d \n", y)
}
